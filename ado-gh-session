#!/usr/bin/env bash

# Define cleanup function to handle termination
cleanup() {
  # Clean up port forwarding connections
  if [ -n "$PORT_FORWARD_PIDS" ]; then
    echo "Cleaning up port forwarding monitor processes..."
    for pid in $PORT_FORWARD_PIDS; do
      echo "Killing port forward monitor process (PID: $pid)..."
      kill $pid 2>/dev/null || true
      wait $pid 2>/dev/null || true
    done
    echo "Port forwarding monitor processes terminated"
  fi
  
  # Clean up individual port forwarding processes
  if [ -f "/tmp/port-forwards-$SOCKET_ID" ]; then
    echo "Cleaning up port forwarding connections..."
    while read -r line; do
      port=$(echo "$line" | cut -d':' -f1)
      pid=$(echo "$line" | cut -d':' -f2)
      echo "Killing port forward for port $port (PID: $pid)..."
      kill $pid 2>/dev/null || true
    done < "/tmp/port-forwards-$SOCKET_ID"
    rm -f "/tmp/port-forwards-$SOCKET_ID"
    echo "All port forwarding connections terminated"
  fi

  # Clean up by killing the auth service process
  if [ -n "$ADO_AUTH_SERVICE_PID" ]; then
    echo "Stopping ado-auth-service (PID: $ADO_AUTH_SERVICE_PID)..."
    kill $ADO_AUTH_SERVICE_PID 2>/dev/null || true
    wait $ADO_AUTH_SERVICE_PID 2>/dev/null || true
    echo "ado-auth-service stopped"
  fi

  # Clean up by killing the port monitor process
  if [ -n "$PORT_MONITOR_PID" ]; then
    echo "Stopping port-monitor (PID: $PORT_MONITOR_PID)..."
    kill $PORT_MONITOR_PID 2>/dev/null || true
    wait $PORT_MONITOR_PID 2>/dev/null || true
    echo "port-monitor stopped"
  fi
  
  # Clean up named pipe
  if [ -p "$PORT_MONITOR_FIFO" ]; then
    rm -f "$PORT_MONITOR_FIFO"
  fi
  
  # Clean up temporary files
  rm -f "/tmp/port-monitor-errors-$SOCKET_ID.log" 2>/dev/null || true
}

# Set up trap to ensure cleanup happens on exit
trap cleanup EXIT INT TERM

# Start the ado-auth-service in the background
auth_service="$(dirname "$0")"/apps/ado-auth-service
echo "Starting ado-auth-service in the background..."
node "$auth_service" &
ADO_AUTH_SERVICE_PID=$!

echo "ado-auth-service started with PID: $ADO_AUTH_SERVICE_PID"
codespace=$(gh cs ls | fzf | awk '{print $1}')
echo "Selected codespace: $codespace"

# Copy the port-monitor to remote machine
port_monitor="$(dirname "$0")"/apps/port-monitor

# Copy the port-monitor to the remote machine
echo "Copying port-monitor to remote machine..."
gh cs cp -c "$codespace" -e "$port_monitor/lib/index.js" 'remote:~/port-monitor.js'

# Create a named pipe for port monitor communication
PORT_MONITOR_FIFO="/tmp/port-monitor-fifo-$SOCKET_ID"
rm -f "$PORT_MONITOR_FIFO"
mkfifo "$PORT_MONITOR_FIFO"

# Function to forward a port
forward_port() {
  local port=$1
  local process_name="port-forward-$port"
  
  echo "Setting up port forwarding for port $port..."
  
  # Check if we're already forwarding this port
  if [[ "$PORT_FORWARD_LIST" == *"$port"* ]]; then
    echo "Port $port is already being forwarded"
    return
  fi
  
  # Start a detached SSH process for port forwarding
  (
    # Run in a subshell with its own process group
    setsid sh -c "exec gh cs ssh -c \"$codespace\" -- -N -L $port:localhost:$port > /dev/null 2>&1" &
    echo "$port:$!" >> "/tmp/port-forwards-$SOCKET_ID"
  )
  
  # Add to our tracking list
  PORT_FORWARD_LIST="$PORT_FORWARD_LIST $port"
  echo "Port $port forwarding established"
}

# Start a background process to monitor the named pipe and establish port forwarding
(
  PORT_FORWARD_PIDS=""
  PORT_FORWARD_LIST=""
  
  # Create a file to track port forwarding processes
  rm -f "/tmp/port-forwards-$SOCKET_ID"
  touch "/tmp/port-forwards-$SOCKET_ID"
  
  echo "Port forwarding monitor started"
  
  while read -r line; do
    # Process JSON output from port-monitor
    if echo "$line" | jq -e '. | select(.type == "port" and .action == "bound")' > /dev/null; then
      # Extract port from the JSON
      port=$(echo "$line" | jq -r .port)
      protocol=$(echo "$line" | jq -r .protocol)
      
      # Only handle TCP ports for now
      if [ "$protocol" = "tcp" ]; then
        echo "Detected new port bound: $port"
        forward_port "$port"
      fi
    elif echo "$line" | jq -e '. | select(.type == "error")' > /dev/null; then
      # Log errors from the port monitor
      message=$(echo "$line" | jq -r .message)
      echo "Port monitor error: $message" >&2
    fi
  done < "$PORT_MONITOR_FIFO" &
  
  # Keep track of this background process
  PORT_FORWARD_MONITOR_PID=$!
  echo "Port forwarding monitor PID: $PORT_FORWARD_MONITOR_PID"
  
  # Add to cleanup
  PORT_FORWARD_PIDS="$PORT_FORWARD_MONITOR_PID"
) &

# Start the port monitor on the remote machine and pipe output to the FIFO
echo "Starting port-monitor on remote machine..."
gh cs ssh -c "$codespace" -- "node \$HOME/port-monitor.js" > "$PORT_MONITOR_FIFO" 2> /tmp/port-monitor-errors-$SOCKET_ID.log &
PORT_MONITOR_PID=$!

# Wait a moment for port monitor to initialize
echo "Port monitor started with PID: $PORT_MONITOR_PID"

# Generate a unique socket ID for this session
SOCKET_ID=$(uuidgen)
SOCKET_PATH="/tmp/ado-auth-${SOCKET_ID}.sock"

# Start an interactive SSH session (no need to forward port again)
echo "Starting interactive SSH session..."
echo "Any ports opened on the remote machine will be automatically forwarded to your local machine."

TERM=xterm-256color gh cs ssh -c "$codespace" -- -R "$SOCKET_PATH:localhost:9000" -t
